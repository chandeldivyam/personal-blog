---
export interface Props {
  headings?: Array<{
    depth: number;
    slug: string;
    text: string;
  }>;
  className?: string;
}

const { headings = [], className = '' } = Astro.props;

// Filter to only include h2, h3, h4 headings and ensure minimum headings for ToC
const tocHeadings = headings.filter(h => h.depth >= 2 && h.depth <= 4);
const showToc = tocHeadings.length >= 3;
---

{showToc && (
  <div class={`toc-container ${className}`}>
    <!-- Mobile toggle button -->
    <button
      type="button"
      id="toc-toggle"
      class="toc-toggle"
      aria-expanded="false"
      aria-controls="toc-content"
      aria-label="Toggle table of contents"
    >
      <svg class="toc-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z"/>
      </svg>
      <span class="toc-toggle-text">Table of Contents</span>
      <svg class="toc-chevron" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
      </svg>
    </button>

    <!-- Table of contents content -->
    <nav id="toc-content" class="toc-content" aria-label="Table of contents">
      <div class="toc-header">
        <h3 class="toc-title">Table of Contents</h3>
      </div>
      <ol class="toc-list">
        {tocHeadings.map((heading) => (
          <li class={`toc-item toc-depth-${heading.depth}`}>
            <a
              href={`#${heading.slug}`}
              class="toc-link"
              data-target={heading.slug}
            >
              {heading.text}
            </a>
          </li>
        ))}
      </ol>
    </nav>
  </div>
)}

<style>
  .toc-container {
    margin: var(--space-lg) 0;
  }

  /* Mobile toggle button */
  .toc-toggle {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    width: 100%;
    padding: var(--space-md);
    background: var(--color-code-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    color: var(--color-text);
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  .toc-toggle:hover {
    background: var(--color-border);
  }

  .toc-toggle[aria-expanded="true"] .toc-chevron {
    transform: rotate(180deg);
  }

  .toc-icon {
    flex-shrink: 0;
    color: var(--color-accent);
  }

  .toc-toggle-text {
    flex: 1;
    text-align: left;
  }

  .toc-chevron {
    flex-shrink: 0;
    transition: transform 0.2s ease;
  }

  /* Table of contents content */
  .toc-content {
    display: none;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-top: none;
    border-radius: 0 0 var(--border-radius) var(--border-radius);
    overflow: hidden;
  }

  .toc-content.expanded {
    display: block;
    animation: slideDown 0.3s ease-out;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .toc-header {
    display: none; /* Hidden on mobile, shown on desktop */
  }

  .toc-title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    margin: 0;
    padding: var(--space-md);
    border-bottom: 1px solid var(--color-border);
    color: var(--color-text);
  }

  .toc-list {
    list-style: none;
    margin: 0;
    padding: var(--space-sm) 0;
    max-height: 60vh;
    overflow-y: auto;
  }

  .toc-item {
    margin: 0;
  }

  .toc-link {
    display: block;
    padding: var(--space-xs) var(--space-md);
    color: var(--color-text-secondary);
    text-decoration: none;
    font-size: 0.875rem;
    line-height: var(--line-height-normal);
    transition: all 0.2s ease;
    border-left: 3px solid transparent;
    position: relative;
  }

  .toc-link:hover {
    color: var(--color-text);
    background: var(--color-code-bg);
    text-decoration: none;
  }

  .toc-link.active {
    color: var(--color-accent);
    background: rgba(204, 82, 0, 0.1);
    border-left-color: var(--color-accent);
    font-weight: 600;
  }

  /* Heading depth indentation */
  .toc-depth-2 .toc-link {
    padding-left: var(--space-md);
  }

  .toc-depth-3 .toc-link {
    padding-left: calc(var(--space-md) + var(--space-lg));
  }

  .toc-depth-4 .toc-link {
    padding-left: calc(var(--space-md) + var(--space-xl));
  }

  /* Desktop styles */
  @media (min-width: 1200px) {
    .toc-container {
      position: sticky;
      top: calc(var(--space-xl) + 60px); /* Account for header height */
      float: right;
      width: 280px;
      margin: 0 0 var(--space-lg) var(--space-lg);
      max-height: calc(100vh - 120px);
      overflow: hidden;
    }

    .toc-toggle {
      display: none;
    }

    .toc-content {
      display: block;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-sm);
    }

    .toc-header {
      display: block;
    }
  }

  /* Reduce motion for users who prefer it */
  @media (prefers-reduced-motion: reduce) {
    .toc-content.expanded {
      animation: none;
    }
    
    .toc-chevron {
      transition: none;
    }
    
    .toc-link {
      transition: none;
    }
  }

  /* Dark theme adjustments */
  [data-theme="dark"] .toc-link.active {
    background: rgba(102, 179, 255, 0.1);
    color: var(--color-accent);
  }

  /* Print styles */
  @media print {
    .toc-container {
      display: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .toc-link.active {
      border-left-width: 4px;
    }
  }
</style>

<script>
  interface TocHandler {
    observer: IntersectionObserver | null;
    headingElements: Element[];
    contentEndElement: Element | null;
    init: () => void;
    setupToggle: () => void;
    setupScrollSpy: () => void;
    setupSmoothScrolling: () => void;
    setActiveLink: (id: string | null | undefined) => void;
    cleanup: () => void;
  }

  const TOC_KEY = '__tocHandler';

  declare global {
    interface Window {
      [TOC_KEY]?: TocHandler;
    }
  }

  if (!window[TOC_KEY]) {
    window[TOC_KEY] = {
      observer: null,
      headingElements: [],
      contentEndElement: null,

      init: function() {
        this.setupToggle();
        this.setupScrollSpy();
        this.setupSmoothScrolling();
      },

      setupToggle: function() {
        const toggle = document.getElementById('toc-toggle');
        const content = document.getElementById('toc-content');
        if (!toggle || !content) return;

        toggle.addEventListener('click', () => {
          const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
          toggle.setAttribute('aria-expanded', String(!isExpanded));
          content.classList.toggle('expanded', !isExpanded);
        });
      },

      setupScrollSpy: function() {
        const articleContent = document.querySelector('.article-content');
        if (!articleContent) return;

        this.headingElements = Array.from(
          articleContent.querySelectorAll('h2[id], h3[id], h4[id]')
        );
        if (this.headingElements.length === 0) return;

        // Find the end of article content (before footer/related sections)
        this.contentEndElement = document.querySelector('.article-footer');

        // Improved observer with better threshold handling
        const observerOptions = {
          rootMargin: '-20% 0px -70% 0px', // Adjusted for better detection
          threshold: [0, 0.25, 0.5, 0.75, 1], // Multiple thresholds for better accuracy
        };

        this.observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {
          // Check if we've scrolled past the article content
          if (this.contentEndElement) {
            const footerRect = this.contentEndElement.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            
            // If footer is in the upper half of viewport, we're past article content
            if (footerRect.top < viewportHeight * 0.5) {
              // Keep the last heading active or clear all
              const lastHeading = this.headingElements[this.headingElements.length - 1];
              if (lastHeading) {
                this.setActiveLink(lastHeading.id);
              }
              return;
            }
          }

          // Find the heading that's most visible in the viewport
          let mostVisibleEntry: IntersectionObserverEntry | null = null;
          let highestRatio = 0;
          let topMostEntry: IntersectionObserverEntry | null = null;
          let topMostPosition = Infinity;

          entries.forEach(entry => {
            const rect = entry.target.getBoundingClientRect();
            
            // Track the topmost visible heading
            if (entry.isIntersecting && rect.top < topMostPosition && rect.top >= 0) {
              topMostPosition = rect.top;
              topMostEntry = entry;
            }

            // Track the most visible heading
            if (entry.isIntersecting && entry.intersectionRatio > highestRatio) {
              highestRatio = entry.intersectionRatio;
              mostVisibleEntry = entry;
            }
          });

          // Prioritize the topmost visible heading if it's near the top of viewport
          if (topMostEntry && topMostPosition < 200) {
            this.setActiveLink(topMostEntry.target.id);
          } else if (mostVisibleEntry) {
            this.setActiveLink(mostVisibleEntry.target.id);
          } else {
            // Fallback: find which heading we're currently scrolled past
            const scrollTop = window.scrollY;
            let activeId = null;
            
            for (let i = this.headingElements.length - 1; i >= 0; i--) {
              const heading = this.headingElements[i] as HTMLElement;
              if (heading.offsetTop <= scrollTop + 150) {
                activeId = heading.id;
                break;
              }
            }
            
            if (activeId) {
              this.setActiveLink(activeId);
            }
          }
        }, observerOptions);

        this.headingElements.forEach(heading => this.observer?.observe(heading));
      },

      setActiveLink: function(activeId: string | null | undefined) {
        document.querySelectorAll('.toc-link').forEach(link => {
          const target = link.getAttribute('data-target');
          if (target === activeId) {
            link.classList.add('active');
            
            // Ensure the active link is visible in the ToC scroll area
            const tocList = document.querySelector('.toc-list');
            if (tocList && link instanceof HTMLElement) {
              const tocRect = tocList.getBoundingClientRect();
              const linkRect = link.getBoundingClientRect();
              
              if (linkRect.top < tocRect.top || linkRect.bottom > tocRect.bottom) {
                link.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }
            }
          } else {
            link.classList.remove('active');
          }
        });
      },

      setupSmoothScrolling: function() {
        document.querySelectorAll('.toc-link').forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = link.getAttribute('data-target');
            if (!targetId) return;

            const targetElement = document.getElementById(targetId);
            if (targetElement) {
              // Calculate offset accounting for sticky header
              const offset = 100;
              const elementPosition = targetElement.getBoundingClientRect().top + window.scrollY - offset;

              // Temporarily disable the observer during programmatic scroll
              const observer = this.observer;
              if (observer) {
                observer.disconnect();
              }

              // Immediately set active state
              this.setActiveLink(targetId);

              window.scrollTo({
                top: elementPosition,
                behavior: 'smooth'
              });

              // Re-enable observer after scroll completes
              setTimeout(() => {
                if (observer && this.headingElements.length > 0) {
                  this.headingElements.forEach(heading => observer.observe(heading));
                }
              }, 1000);

              // Close mobile ToC after clicking
              const toggle = document.getElementById('toc-toggle');
              const content = document.getElementById('toc-content');
              if (toggle && content && window.innerWidth < 1200) {
                content.classList.remove('expanded');
                toggle.setAttribute('aria-expanded', 'false');
              }
            }
          });
        });
      },

      cleanup: function() {
        if (this.observer) {
          this.observer.disconnect();
          this.observer = null;
        }
        this.headingElements = [];
        this.contentEndElement = null;
      }
    };
  }

  function attachTableOfContents() {
    const handler = window[TOC_KEY];
    const tocContainer = document.querySelector('.toc-container');
    if (handler && tocContainer) {
      handler.cleanup();
      handler.init();
    }
  }

  // Attach on initial load
  attachTableOfContents();

  // Re-attach after each navigation with View Transitions
  document.addEventListener('astro:after-swap', attachTableOfContents);

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    const handler = (window as any)[TOC_KEY];
    if (handler) {
      handler.cleanup();
    }
  });
</script>